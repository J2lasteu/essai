{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"La sp\u00e9cialit\u00e9 Num\u00e9rique Sciences de l'Informatique PREMI\u00c8RE TERMINALE Histoire de l\u2019informatique --> A venir Repr\u00e9sentation des donn\u00e9es : Types et valeur de base Repr\u00e9sentation des donn\u00e9es : Types construits --> A venir Traitement de donn\u00e9es en tables --> A venir Interactions entre l\u2019homme et la machine sur le Web --> A venir Architectures mat\u00e9rielles et syst\u00e8mes d\u2019exploitation --> A venir Langages et programmation Les Bases en Python Algorithmiques R\u00e9visions Bases de donn\u00e9es - Langage SQL R\u00e9cursivit\u00e9 La programmation orient\u00e9e objet Les arbres Les piles Les files Les graphes Les processus Le routage : RIP et OSFP Diviser pour r\u00e9gner","title":"Accueil"},{"location":"#la-specialite-numerique-sciences-de-linformatique","text":"PREMI\u00c8RE TERMINALE Histoire de l\u2019informatique --> A venir Repr\u00e9sentation des donn\u00e9es : Types et valeur de base Repr\u00e9sentation des donn\u00e9es : Types construits --> A venir Traitement de donn\u00e9es en tables --> A venir Interactions entre l\u2019homme et la machine sur le Web --> A venir Architectures mat\u00e9rielles et syst\u00e8mes d\u2019exploitation --> A venir Langages et programmation Les Bases en Python Algorithmiques R\u00e9visions Bases de donn\u00e9es - Langage SQL R\u00e9cursivit\u00e9 La programmation orient\u00e9e objet Les arbres Les piles Les files Les graphes Les processus Le routage : RIP et OSFP Diviser pour r\u00e9gner","title":"La sp\u00e9cialit\u00e9 Num\u00e9rique Sciences de l'Informatique"},{"location":"a_propos/","text":"Ce site est en construction!","title":"A propos"},{"location":"a_propos/#ce-site-est-en-construction","text":"","title":"Ce site est en construction!"},{"location":"1NSI/Algorithmique/Tri/Tri/","text":"Tri S\u00e9lection Tri Insertion 1. Animation Tri S\u00e9lection Consid\u00e9rons la liste [5, 4, 2, 1] Voici le fonctionnement de l'algorithme : 2. Principe Tri S\u00e9lection description de l'algorithme Attention un tableau de 4 valeurs (4 cases) sera num\u00e9rot\u00e9 de 0 \u00e0 3 et non de 1 \u00e0 4 Sur un tableau de n \u00e9l\u00e9ments (num\u00e9rot\u00e9s de 0 \u00e0 n-1), le principe du tri par s\u00e9lection est le suivant : rechercher le plus petit \u00e9l\u00e9ment du tableau, et l'\u00e9changer avec l'\u00e9l\u00e9ment d'indice 0 ; rechercher le second plus petit \u00e9l\u00e9ment du tableau, et l'\u00e9changer avec l'\u00e9l\u00e9ment d'indice 1 ; continuer de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. En pseudo-code, l'algorithme s'\u00e9crit ainsi : Python fonction tri_selection ( tableau t ): n \u2190 longueur ( t ) pour i de 0 \u00e0 n - 2 indice_min \u2190 i pour j de i + 1 \u00e0 n si t [ j ] < t [ indice_min ], alors indice_min \u2190 j fin pour si indice_min \u2260 i , alors \u00e9changer t [ i ] et t [ indice_min ] fin pour fin fonction 3. Impl\u00e9mentation de l'algorithme Tri S\u00e9lection Tri par s\u00e9lection Python def tri_selection ( tab ) : n = len ( tab ) for i in range ( n - 2 ): indice_min = i for j in range ( i + 1 , n ) : if tab [ j ] < tab [ indice_min ]: indice_min = j # Inversion if indice_min != i : tmp = tab [ i ] tab [ i ] = tab [ indice_min ] tab [ indice_min ] = tmp V\u00e9rification : Python >>> ma_liste = [ 7 , 5 , 2 , 8 , 1 , 4 ] >>> tri_selection ( ma_liste ) >>> ma_liste [ 1 , 2 , 4 , 5 , 7 , 8 ] Pour v\u00e9rifier avec PythonTutor, cliquer ici 4. Complexit\u00e9 de l'algorithme 4.1 Mesure du temps d'ex\u00e9cution Nous allons fabriquer deux listes de taille 100 et 200 : Python lst_a = [ k for k in range ( 100 , 0 , - 1 )] #on se place dans le pire des cas : une liste tri\u00e9e dans l'ordre d\u00e9croissant lst_b = [ k for k in range ( 200 , 0 , - 1 )] #on se place dans le pire des cas : une liste tri\u00e9e dans l'ordre d\u00e9croissant On peut aussi utiliser la fonction random pour cr\u00e9er des listes de mani\u00e8res al\u00e9atoire Ici on cr\u00e9e une liste de 10 chiffres compris entre 0 et 999 Python import random tab = [ random . randint ( 0 , 1000 ) for i in range ( 10 )] print ( tab ) La mesure du temps moyen de tri pour ces deux listes donne le r\u00e9sultat ci-dessous (avec le module timeit sous Jupyter Notebook) Python % timeit tri_selection ( lst_a ) 632 \u00b5s \u00b1 14.3 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 1000 loops each ) Python % timeit tri_selection ( lst_b ) 2.35 ms \u00b1 35.9 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 100 loops each ) Voici l'algorithme \u00e0 saisir sur un notebook Jupyter Python def tri_selection ( tab ) : n = len ( tab ) for i in range ( n - 2 ): indice_min = i for j in range ( i + 1 , n ) : if tab [ j ] < tab [ indice_min ]: indice_min = j # Inversion if indice_min != i : tmp = tab [ i ] tab [ i ] = tab [ indice_min ] tab [ indice_min ] = tmp lst_a = [ k for k in range ( 100 , 0 , - 1 )] #on se place dans le pire des cas : une liste tri\u00e9e dans l'ordre d\u00e9croissant lst_b = [ k for k in range ( 200 , 0 , - 1 )] #on se place dans le pire des cas : une liste tri\u00e9e dans l'ordre d\u00e9croissant print ( 'Voici le temps de tri pour la liste lst_a' ) % timeit tri_selection ( lst_a ) print ( 'Voici le temps de tri pour la liste lst_b' ) % timeit tri_selection ( lst_b ) En comparant les temps de tri des listes lst_a et lst_b , que pouvez-vous supposer sur la complexit\u00e9 du tri par s\u00e9lection ? R\u00e9ponse Une liste \u00e0 trier 2 fois plus longue prend 4 fois plus de temps : l'algorithme semble de complexit\u00e9 quadratique . Pire cas : \\(O(n^2)\\) Moyenne : \\(O(n^2)\\) Meilleur cas : \\(O(n^2)\\) 4.2. Calcul du nombre d'op\u00e9rations D\u00e9nombrons le nombre d'op\u00e9rations, pour une liste de taille \\(n\\) . boucle for : elle s'ex\u00e9cute \\(n-1\\) fois. deuxi\u00e8me boucle for imbriqu\u00e9e : elle ex\u00e9cute d'abord 1 op\u00e9ration, puis 2, puis 3... jusqu'\u00e0 \\(n-1\\) . Or \\(1+2+3+\\dots+n-1=\\dfrac{n \\times (n-1)}{2}\\) Ceci est bien un polyn\u00f4me du second degr\u00e9, ce qui confirme que la complexit\u00e9 de ce tri est quadratique. V\u00e9rification exp\u00e9rimentale Ins\u00e9rer un compteur c dans votre algorithme pour v\u00e9rifier le calcul pr\u00e9c\u00e9dent. On pourra renvoyer cette valeur en fin d'algorithme par un return c . Voici l'algorithme \u00e0 saisir sur un notebook Jupyter Python def tri_selection1 ( tab ) : n = len ( tab ) c = 0 for i in range ( n - 2 ): indice_min = i for j in range ( i + 1 , n ) : c += 1 if tab [ j ] < tab [ indice_min ]: indice_min = j # Inversion if indice_min != i : tmp = tab [ i ] tab [ i ] = tab [ indice_min ] tab [ indice_min ] = tmp return c lst_a = [ k for k in range ( 100 , 0 , - 1 )] #on se place dans le pire des cas : une liste tri\u00e9e dans l'ordre d\u00e9croissant tri_selection1 ( lst_a ) lst_b = [ k for k in range ( 200 , 0 , - 1 )] #on se place dans le pire des cas : une liste tri\u00e9e dans l'ordre d\u00e9croissant tri_selection1 ( lst_b ) 5. Preuve de la correction de l'algorithme Est-on s\u00fbr que notre algorithme va bien trier notre liste ? Les preuves de correction sont des preuves th\u00e9oriques. La preuve ici s'appuie sur le concept math\u00e9matique de r\u00e9currence . Principe du raisonnement par r\u00e9currence : une propri\u00e9t\u00e9 \\(P(n)\\) est vraie si : \\(P(0)\\) (par exemple) est vraie Pour tout entier naturel \\(n\\) , si \\(P(n)\\) est vraie alors \\(P(n+1)\\) est vraie. Ici, la propri\u00e9t\u00e9 serait : \u00ab Quand \\(i\\) varie entre 0 et longueur(liste) -2 , la sous-liste de longueur \\(i\\) est tri\u00e9e dans l'ordre croissant.\u00bb On appelle cette propri\u00e9t\u00e9 un invariant de boucle (sous-entendu : elle est vraie pour chaque boucle) - quand \\(i\\) vaut 0, on place le minimum de la liste en l[0], la sous-liste l[0] est donc tri\u00e9e. - si la sous-liste de \\(i\\) \u00e9l\u00e9ments est tri\u00e9e, l'algorithme rajoute en derni\u00e8re position de la liste le minimum de la sous-liste restante, dont tous les \u00e9l\u00e9ments sont sup\u00e9rieurs au maximum de la sous-liste de \\(i\\) \u00e9l\u00e9ments. La sous-liste de \\(i+1\\) \u00e9l\u00e9ments est donc aussi tri\u00e9e. 6. Preuve de la terminaison de l'algorithme Est-on s\u00fbr que notre algorithme va s'arr\u00eater ? \u00c0 l'observation du programme, constitu\u00e9 de deux boucles for imbriqu\u00e9es, il n'y a pas d'ambigu\u00eft\u00e9 : on ne peut pas rentrer dans une boucle infinie. Le programme s'arr\u00eate forc\u00e9ment au bout de d'un nombre fixe d'op\u00e9rations. D'apr\u00e8s nos calculs sur la complexit\u00e9, ce nombre de tours de boucles est \u00e9gal \u00e0 \\(\\dfrac{n \\times (n-1)}{2}\\) . Ceci prouve que l'algorithme se terminera. 7. Bonus : comparaison des algorithmes de tri Une d\u00e9monstration du tri par s\u00e9lection cliquer --> ici Une jolie animation permettant de comparer les tris : Issue de ce site 1. Animation Tri Insertion Consid\u00e9rons la liste [7, 5, 2, 8, 1, 4] Voici le fonctionnement de l'algorithme : 2. Principe Tri Insertion description de l'algorithme On traite successivement toutes les valeurs \u00e0 trier, en commen\u00e7ant par celle en deuxi\u00e8me position. Traitement : tant que la valeur \u00e0 traiter est inf\u00e9rieure \u00e0 celle situ\u00e9e \u00e0 sa gauche, on \u00e9change ces deux valeurs. 3. Impl\u00e9mentation de l'algorithme Tri Insertion Tri par insertion (version simple) Python def tri_insertion1 ( tab ): '''trie en place la liste tab donn\u00e9e en param\u00e8tre''' for i in range ( 1 , len ( tab )): #(1) k = i #(2) while k > 0 and tab [ k - 1 ] > tab [ k ] : #(3) tab [ k ], tab [ k - 1 ] = tab [ k - 1 ], tab [ k ] #(4) k = k - 1 #(5) On commence \u00e0 1 et non pas \u00e0 0. On \u00abduplique\u00bb la variable i en une variable k . On se positionne sur l'\u00e9l\u00e9ment d'indice k . On va faire \u00abreculer\u00bb cet \u00e9l\u00e9ment tant que c'est possible. On ne touche pas \u00e0 i . Tant qu'on n'est pas revenu au d\u00e9but de la liste et qu'il y a une valeur plus grande \u00e0 gauche. On \u00e9change de place avec l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent. Notre \u00e9l\u00e9ment est maintenant \u00e0 l'indice k - 1 . La boucle peut continuer. Pour v\u00e9rifier sur PythonTutor, cliquer ici V\u00e9rification : Python >>> maliste = [ 7 , 5 , 2 , 8 , 1 , 4 ] >>> tri_insertion1 ( maliste ) >>> maliste [ 1 , 2 , 4 , 5 , 7 , 8 ] \ud83d\udcc4 Accueil","title":"8 : Algorithmique"},{"location":"1NSI/Algorithmique/Tri/Tri/#1-animation-tri-selection","text":"Consid\u00e9rons la liste [5, 4, 2, 1] Voici le fonctionnement de l'algorithme :","title":"1. Animation Tri S\u00e9lection"},{"location":"1NSI/Algorithmique/Tri/Tri/#2-principe-tri-selection","text":"description de l'algorithme Attention un tableau de 4 valeurs (4 cases) sera num\u00e9rot\u00e9 de 0 \u00e0 3 et non de 1 \u00e0 4 Sur un tableau de n \u00e9l\u00e9ments (num\u00e9rot\u00e9s de 0 \u00e0 n-1), le principe du tri par s\u00e9lection est le suivant : rechercher le plus petit \u00e9l\u00e9ment du tableau, et l'\u00e9changer avec l'\u00e9l\u00e9ment d'indice 0 ; rechercher le second plus petit \u00e9l\u00e9ment du tableau, et l'\u00e9changer avec l'\u00e9l\u00e9ment d'indice 1 ; continuer de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. En pseudo-code, l'algorithme s'\u00e9crit ainsi : Python fonction tri_selection ( tableau t ): n \u2190 longueur ( t ) pour i de 0 \u00e0 n - 2 indice_min \u2190 i pour j de i + 1 \u00e0 n si t [ j ] < t [ indice_min ], alors indice_min \u2190 j fin pour si indice_min \u2260 i , alors \u00e9changer t [ i ] et t [ indice_min ] fin pour fin fonction","title":"2. Principe Tri S\u00e9lection"},{"location":"1NSI/Algorithmique/Tri/Tri/#3-implementation-de-lalgorithme-tri-selection","text":"Tri par s\u00e9lection Python def tri_selection ( tab ) : n = len ( tab ) for i in range ( n - 2 ): indice_min = i for j in range ( i + 1 , n ) : if tab [ j ] < tab [ indice_min ]: indice_min = j # Inversion if indice_min != i : tmp = tab [ i ] tab [ i ] = tab [ indice_min ] tab [ indice_min ] = tmp V\u00e9rification : Python >>> ma_liste = [ 7 , 5 , 2 , 8 , 1 , 4 ] >>> tri_selection ( ma_liste ) >>> ma_liste [ 1 , 2 , 4 , 5 , 7 , 8 ] Pour v\u00e9rifier avec PythonTutor, cliquer ici","title":"3. Impl\u00e9mentation de l'algorithme Tri S\u00e9lection"},{"location":"1NSI/Algorithmique/Tri/Tri/#4-complexite-de-lalgorithme","text":"","title":"4. Complexit\u00e9 de l'algorithme"},{"location":"1NSI/Algorithmique/Tri/Tri/#41-mesure-du-temps-dexecution","text":"Nous allons fabriquer deux listes de taille 100 et 200 : Python lst_a = [ k for k in range ( 100 , 0 , - 1 )] #on se place dans le pire des cas : une liste tri\u00e9e dans l'ordre d\u00e9croissant lst_b = [ k for k in range ( 200 , 0 , - 1 )] #on se place dans le pire des cas : une liste tri\u00e9e dans l'ordre d\u00e9croissant On peut aussi utiliser la fonction random pour cr\u00e9er des listes de mani\u00e8res al\u00e9atoire Ici on cr\u00e9e une liste de 10 chiffres compris entre 0 et 999 Python import random tab = [ random . randint ( 0 , 1000 ) for i in range ( 10 )] print ( tab ) La mesure du temps moyen de tri pour ces deux listes donne le r\u00e9sultat ci-dessous (avec le module timeit sous Jupyter Notebook) Python % timeit tri_selection ( lst_a ) 632 \u00b5s \u00b1 14.3 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 1000 loops each ) Python % timeit tri_selection ( lst_b ) 2.35 ms \u00b1 35.9 \u00b5s per loop ( mean \u00b1 std . dev . of 7 runs , 100 loops each ) Voici l'algorithme \u00e0 saisir sur un notebook Jupyter Python def tri_selection ( tab ) : n = len ( tab ) for i in range ( n - 2 ): indice_min = i for j in range ( i + 1 , n ) : if tab [ j ] < tab [ indice_min ]: indice_min = j # Inversion if indice_min != i : tmp = tab [ i ] tab [ i ] = tab [ indice_min ] tab [ indice_min ] = tmp lst_a = [ k for k in range ( 100 , 0 , - 1 )] #on se place dans le pire des cas : une liste tri\u00e9e dans l'ordre d\u00e9croissant lst_b = [ k for k in range ( 200 , 0 , - 1 )] #on se place dans le pire des cas : une liste tri\u00e9e dans l'ordre d\u00e9croissant print ( 'Voici le temps de tri pour la liste lst_a' ) % timeit tri_selection ( lst_a ) print ( 'Voici le temps de tri pour la liste lst_b' ) % timeit tri_selection ( lst_b ) En comparant les temps de tri des listes lst_a et lst_b , que pouvez-vous supposer sur la complexit\u00e9 du tri par s\u00e9lection ? R\u00e9ponse Une liste \u00e0 trier 2 fois plus longue prend 4 fois plus de temps : l'algorithme semble de complexit\u00e9 quadratique . Pire cas : \\(O(n^2)\\) Moyenne : \\(O(n^2)\\) Meilleur cas : \\(O(n^2)\\)","title":"4.1 Mesure du temps d'ex\u00e9cution"},{"location":"1NSI/Algorithmique/Tri/Tri/#42-calcul-du-nombre-doperations","text":"D\u00e9nombrons le nombre d'op\u00e9rations, pour une liste de taille \\(n\\) . boucle for : elle s'ex\u00e9cute \\(n-1\\) fois. deuxi\u00e8me boucle for imbriqu\u00e9e : elle ex\u00e9cute d'abord 1 op\u00e9ration, puis 2, puis 3... jusqu'\u00e0 \\(n-1\\) . Or \\(1+2+3+\\dots+n-1=\\dfrac{n \\times (n-1)}{2}\\) Ceci est bien un polyn\u00f4me du second degr\u00e9, ce qui confirme que la complexit\u00e9 de ce tri est quadratique. V\u00e9rification exp\u00e9rimentale Ins\u00e9rer un compteur c dans votre algorithme pour v\u00e9rifier le calcul pr\u00e9c\u00e9dent. On pourra renvoyer cette valeur en fin d'algorithme par un return c . Voici l'algorithme \u00e0 saisir sur un notebook Jupyter Python def tri_selection1 ( tab ) : n = len ( tab ) c = 0 for i in range ( n - 2 ): indice_min = i for j in range ( i + 1 , n ) : c += 1 if tab [ j ] < tab [ indice_min ]: indice_min = j # Inversion if indice_min != i : tmp = tab [ i ] tab [ i ] = tab [ indice_min ] tab [ indice_min ] = tmp return c lst_a = [ k for k in range ( 100 , 0 , - 1 )] #on se place dans le pire des cas : une liste tri\u00e9e dans l'ordre d\u00e9croissant tri_selection1 ( lst_a ) lst_b = [ k for k in range ( 200 , 0 , - 1 )] #on se place dans le pire des cas : une liste tri\u00e9e dans l'ordre d\u00e9croissant tri_selection1 ( lst_b )","title":"4.2. Calcul du nombre d'op\u00e9rations"},{"location":"1NSI/Algorithmique/Tri/Tri/#5-preuve-de-la-correction-de-lalgorithme","text":"Est-on s\u00fbr que notre algorithme va bien trier notre liste ? Les preuves de correction sont des preuves th\u00e9oriques. La preuve ici s'appuie sur le concept math\u00e9matique de r\u00e9currence . Principe du raisonnement par r\u00e9currence : une propri\u00e9t\u00e9 \\(P(n)\\) est vraie si : \\(P(0)\\) (par exemple) est vraie Pour tout entier naturel \\(n\\) , si \\(P(n)\\) est vraie alors \\(P(n+1)\\) est vraie. Ici, la propri\u00e9t\u00e9 serait : \u00ab Quand \\(i\\) varie entre 0 et longueur(liste) -2 , la sous-liste de longueur \\(i\\) est tri\u00e9e dans l'ordre croissant.\u00bb On appelle cette propri\u00e9t\u00e9 un invariant de boucle (sous-entendu : elle est vraie pour chaque boucle) - quand \\(i\\) vaut 0, on place le minimum de la liste en l[0], la sous-liste l[0] est donc tri\u00e9e. - si la sous-liste de \\(i\\) \u00e9l\u00e9ments est tri\u00e9e, l'algorithme rajoute en derni\u00e8re position de la liste le minimum de la sous-liste restante, dont tous les \u00e9l\u00e9ments sont sup\u00e9rieurs au maximum de la sous-liste de \\(i\\) \u00e9l\u00e9ments. La sous-liste de \\(i+1\\) \u00e9l\u00e9ments est donc aussi tri\u00e9e.","title":"5. Preuve de la correction de l'algorithme"},{"location":"1NSI/Algorithmique/Tri/Tri/#6-preuve-de-la-terminaison-de-lalgorithme","text":"Est-on s\u00fbr que notre algorithme va s'arr\u00eater ? \u00c0 l'observation du programme, constitu\u00e9 de deux boucles for imbriqu\u00e9es, il n'y a pas d'ambigu\u00eft\u00e9 : on ne peut pas rentrer dans une boucle infinie. Le programme s'arr\u00eate forc\u00e9ment au bout de d'un nombre fixe d'op\u00e9rations. D'apr\u00e8s nos calculs sur la complexit\u00e9, ce nombre de tours de boucles est \u00e9gal \u00e0 \\(\\dfrac{n \\times (n-1)}{2}\\) . Ceci prouve que l'algorithme se terminera.","title":"6.\u00a0Preuve de la terminaison de l'algorithme"},{"location":"1NSI/Algorithmique/Tri/Tri/#7-bonus-comparaison-des-algorithmes-de-tri","text":"Une d\u00e9monstration du tri par s\u00e9lection cliquer --> ici Une jolie animation permettant de comparer les tris : Issue de ce site","title":"7. Bonus : comparaison des algorithmes de tri"},{"location":"1NSI/Algorithmique/Tri/Tri/#1-animation-tri-insertion","text":"Consid\u00e9rons la liste [7, 5, 2, 8, 1, 4] Voici le fonctionnement de l'algorithme :","title":"1. Animation Tri Insertion"},{"location":"1NSI/Algorithmique/Tri/Tri/#2-principe-tri-insertion","text":"description de l'algorithme On traite successivement toutes les valeurs \u00e0 trier, en commen\u00e7ant par celle en deuxi\u00e8me position. Traitement : tant que la valeur \u00e0 traiter est inf\u00e9rieure \u00e0 celle situ\u00e9e \u00e0 sa gauche, on \u00e9change ces deux valeurs.","title":"2. Principe Tri Insertion"},{"location":"1NSI/Algorithmique/Tri/Tri/#3-implementation-de-lalgorithme-tri-insertion","text":"Tri par insertion (version simple) Python def tri_insertion1 ( tab ): '''trie en place la liste tab donn\u00e9e en param\u00e8tre''' for i in range ( 1 , len ( tab )): #(1) k = i #(2) while k > 0 and tab [ k - 1 ] > tab [ k ] : #(3) tab [ k ], tab [ k - 1 ] = tab [ k - 1 ], tab [ k ] #(4) k = k - 1 #(5) On commence \u00e0 1 et non pas \u00e0 0. On \u00abduplique\u00bb la variable i en une variable k . On se positionne sur l'\u00e9l\u00e9ment d'indice k . On va faire \u00abreculer\u00bb cet \u00e9l\u00e9ment tant que c'est possible. On ne touche pas \u00e0 i . Tant qu'on n'est pas revenu au d\u00e9but de la liste et qu'il y a une valeur plus grande \u00e0 gauche. On \u00e9change de place avec l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent. Notre \u00e9l\u00e9ment est maintenant \u00e0 l'indice k - 1 . La boucle peut continuer. Pour v\u00e9rifier sur PythonTutor, cliquer ici V\u00e9rification : Python >>> maliste = [ 7 , 5 , 2 , 8 , 1 , 4 ] >>> tri_insertion1 ( maliste ) >>> maliste [ 1 , 2 , 4 , 5 , 7 , 8 ] \ud83d\udcc4 Accueil","title":"3. Impl\u00e9mentation de l'algorithme Tri Insertion"},{"location":"1NSI/ch01/bases/","text":"Bases de Python Site d'apprentissage Python Exercices Niveau 1 Niveau D\u00e9butant Futurtecoder Niveau Interm\u00e9diaire France IOI Niveau Professionnel Exercice N\u00b01 En 1 ligne, afficher le message \"Bonjour \u00e0 tous\" ### Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder Exercice N\u00b02 A l'aide d'une boucle for, afficher le message \"Bonjour \u00e0 tous\" trois fois ### Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder","title":"7.1 : Les bases"},{"location":"1NSI/ch01/bases/#bases-de-python","text":"Site d'apprentissage Python Exercices Niveau 1 Niveau D\u00e9butant Futurtecoder Niveau Interm\u00e9diaire France IOI Niveau Professionnel Exercice N\u00b01 En 1 ligne, afficher le message \"Bonjour \u00e0 tous\" ### Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder Exercice N\u00b02 A l'aide d'une boucle for, afficher le message \"Bonjour \u00e0 tous\" trois fois ### Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder","title":"Bases de Python"},{"location":"1NSI/ch02/ch02/","text":"Repr\u00e9sentation des donn\u00e9es \u00c9criture d\u2019un entier positif dans une base b \u2a7e 2 A VENIR Repr\u00e9sentation binaire d\u2019un entier relatif A VENIR Repr\u00e9sentation approximative des nombres r\u00e9els : notion de nombre flottant A VENIR Valeurs bool\u00e9ennes : 0, 1. Op\u00e9rateurs bool\u00e9ens : and, or, not. Expressions bool\u00e9ennes A VENIR Repr\u00e9sentation d\u2019un texte en machine. Exemples des encodages ASCII, ISO-8859-1, Unicode A VENIR","title":"2 : Repr\u00e9sentation des donn\u00e9es"},{"location":"1NSI/ch02/ch02/#representation-des-donnees","text":"\u00c9criture d\u2019un entier positif dans une base b \u2a7e 2 A VENIR Repr\u00e9sentation binaire d\u2019un entier relatif A VENIR Repr\u00e9sentation approximative des nombres r\u00e9els : notion de nombre flottant A VENIR Valeurs bool\u00e9ennes : 0, 1. Op\u00e9rateurs bool\u00e9ens : and, or, not. Expressions bool\u00e9ennes A VENIR Repr\u00e9sentation d\u2019un texte en machine. Exemples des encodages ASCII, ISO-8859-1, Unicode A VENIR","title":"Repr\u00e9sentation des donn\u00e9es"},{"location":"TNSI/Bases_De_Donnees/Bases_De_Donnees/","text":"Cours Exercices Pour la gestion des accents sur les fichiers SQL clique ICI Agences de locations de voitures Le sch\u00e9ma relationnel Visualiser toute la relation Agences Exemple : SQL SELECT * FROM vehicules WHERE kilometrage > 10000 Tape ta requ\u00eate SQL ici : Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, '/', 'BEGIN TRANSACTION;\\nPRAGMA foreign_keys = ON;\\n\\n\\n\\nCREATE TABLE IF NOT EXISTS `vehicules` (\\n `immatriculation` TEXT NOT NULL,\\n `nom` TEXT,\\n `kilometrage` INTEGER,\\n `age` INTEGER,\\n PRIMARY KEY(`immatriculation`)\\n);\\n\\nINSERT INTO `vehicules` VALUES (\\'AB-224-BA\\',\\'Renault Megane\\',156107,6);\\nINSERT INTO `vehicules` VALUES (\\'CB-424-BC\\',\\'Renault Megane\\',55108,3);\\nINSERT INTO `vehicules` VALUES (\\'DB-566-DF\\',\\'Renault Megane\\',165150,5);\\nINSERT INTO `vehicules` VALUES (\\'CC-259-FF\\',\\'Renault Twingo\\',61458,5);\\nINSERT INTO `vehicules` VALUES (\\'DF-269-EF\\',\\'Renault Twingo\\',134340,5);\\nINSERT INTO `vehicules` VALUES (\\'DE-254-AE\\',\\'Peugeot 108\\',215460,4);\\nINSERT INTO `vehicules` VALUES (\\'ED-587-EE\\',\\'Peugeot 108\\',155465,4);\\nINSERT INTO `vehicules` VALUES (\\'AA-654-BA\\',\\'Peugeot 108\\',115890,6);\\nINSERT INTO `vehicules` VALUES (\\'EE-854-EF\\',\\'Citro&eumln C4\\',91105,6);\\nINSERT INTO `vehicules` VALUES (\\'AE-478-DD\\',\\'Citro&eumln C5\\',2589,8);\\nCREATE TABLE `locations` (\\n `id` INTEGER NOT NULL,\\n `vehicule` TEXT,\\n `depart` INTEGER NOT NULL,\\n `retour` INTEGER NOT NULL,\\n `kilometrage` integer,\\n `date` timestamp without time zone,\\n `duree` integer,\\n PRIMARY KEY(`id`)\\n foreign key (vehicule) references vehicules(immatriculation)\\n foreign key (depart) references agences(id)\\n foreign key (retour) references agences(id)\\n \\n);\\nINSERT INTO `locations` VALUES (1,\\'AB-224-BA\\',1,1,452,\\'2020-05-03\\',1);\\nINSERT INTO `locations` VALUES (2,\\'AB-224-BA\\',1,3,1354,\\'2020-06-05\\',2);\\nINSERT INTO `locations` VALUES (3,\\'AB-224-BA\\',3,1,1402,\\'2020-07-10\\',1);\\nINSERT INTO `locations` VALUES (4,\\'CB-424-BC\\',1,1,1457,\\'2020-05-10\\',1);\\nINSERT INTO `locations` VALUES (5,\\'CB-424-BC\\',1,1,153,\\'2020-01-02\\',1);\\nINSERT INTO `locations` VALUES (6,\\'DB-566-DF\\',2,2,457,\\'2020-06-24\\',1);\\nINSERT INTO `locations` VALUES (7,\\'DB-566-DF\\',5,1,1584,\\'2020-08-30\\',1);\\nINSERT INTO `locations` VALUES (8,\\'DF-269-EF\\',7,1,1358,\\'2020-02-19\\',1);\\nINSERT INTO `locations` VALUES (9,\\'ED-587-EE\\',1,7,1587,\\'2020-04-11\\',1);\\nINSERT INTO `locations` VALUES (10,\\'EE-854-EF\\',4,4,1333,\\'2020-11-08\\',3);\\nINSERT INTO `locations` VALUES (11,\\'ED-587-EE\\',4,2,1248,\\'2020-10-01\\',1);\\nINSERT INTO `locations` VALUES (12,\\'EE-854-EF\\',7,7,1387,\\'2020-05-05\\',1);\\nINSERT INTO `locations` VALUES (13,\\'DF-269-EF\\',6,6,457,\\'2020-07-08\\',1);\\nINSERT INTO `locations` VALUES (14,\\'CC-259-FF\\',6,6,310,\\'2020-09-09\\',1);\\nINSERT INTO `locations` VALUES (15,\\'AB-224-BA\\',6,1,745,\\'2020-04-10\\',1);\\nINSERT INTO `locations` VALUES (16,\\'DB-566-DF\\',7,8,387,\\'2020-07-11\\',1);\\nINSERT INTO `locations` VALUES (17,\\'CC-259-FF\\',8,8,1159,\\'2020-08-20\\',1);\\nINSERT INTO `locations` VALUES (18,\\'DF-269-EF\\',3,1,147,\\'2020-11-23\\',1);\\nINSERT INTO `locations` VALUES (19,\\'DE-254-AE\\',5,5,1147,\\'2020-10-17\\',1);\\nINSERT INTO `locations` VALUES (20,\\'AA-654-BA\\',6,6,1357,\\'2020-11-27\\',1);\\nINSERT INTO `locations` VALUES (21,\\'ED-587-EE\\',6,6,1485,\\'2020-10-29\\',1);\\nINSERT INTO `locations` VALUES (22,\\'CC-259-FF\\',7,7,1597,\\'2020-09-30\\',1);\\nINSERT INTO `locations` VALUES (23,\\'DB-566-DF\\',7,8,1357,\\'2020-06-18\\',3);\\nINSERT INTO `locations` VALUES (24,\\'EE-854-EF\\',9,9,1248,\\'2020-09-20\\',1);\\nINSERT INTO `locations` VALUES (25,\\'CC-259-FF\\',2,2,1456,\\'2020-05-16\\',2);\\nINSERT INTO `locations` VALUES (26,\\'DE-254-AE\\',2,3,1789,\\'2020-03-15\\',2);\\nINSERT INTO `locations` VALUES (27,\\'AB-224-BA\\',1,1,1374,\\'2020-05-12\\',1);\\nINSERT INTO `locations` VALUES (28,\\'AB-224-BA\\',1,5,1080,\\'2020-07-15\\',1);\\nINSERT INTO `locations` VALUES (29,\\'AB-224-BA\\',5,5,680,\\'2020-07-18\\',1);\\nINSERT INTO `locations` VALUES (30,\\'AB-224-BA\\',5,6,240,\\'2020-08-05\\',1);\\nINSERT INTO `locations` VALUES (31,\\'AB-224-BA\\',6,1,168,\\'2020-08-08\\',1);\\nINSERT INTO `locations` VALUES (32,\\'CB-424-BC\\',6,6,1457,\\'2020-04-09\\',1);\\nINSERT INTO `locations` VALUES (33,\\'DF-269-EF\\',3,3,183,\\'2020-06-15\\',2);\\nINSERT INTO `locations` VALUES (34,\\'DF-269-EF\\',3,1,NULL,\\'2020-12-24\\',1);\\nINSERT INTO `locations` VALUES (35,\\'DE-254-AE\\',5,5,NULL,\\'2020-12-24\\',1);\\nINSERT INTO `locations` VALUES (36,\\'AA-654-BA\\',7,7,NULL,\\'2020-12-24\\',1);\\nINSERT INTO `locations` VALUES (37,\\'CB-424-BC\\',3,6,NULL,\\'2020-12-24\\',2);\\nINSERT INTO `locations` VALUES (38,\\'DB-566-DF\\',4,8,NULL,\\'2020-12-24\\',1);\\nINSERT INTO `locations` VALUES (39,\\'EE-854-EF\\',9,9,NULL,\\'2020-10-23\\',0);\\nINSERT INTO `locations` VALUES (40,\\'AE-478-DD\\',1,1,NULL,\\'2020-06-01\\',0);\\nCREATE TABLE IF NOT EXISTS `agences` (\\n `id` INTEGER NOT NULL,\\n `nom` TEXT,\\n `adresse` TEXT,\\n `code` TEXT,\\n `ville` TEXT,\\n `pays` TEXT,\\n PRIMARY KEY(`id`)\\n);\\n\\nINSERT INTO `agences` VALUES (1,\\'S&eacutepamieuayeur\\',\\'5 quai des bavards\\',\\'56100\\',\\'Lorient\\',\\'France\\');\\nINSERT INTO `agences` VALUES (2,\\'Moincheryapa\\',\\'4 rue Parmentier\\',\\'56100\\',\\'Lorient\\',\\'France\\');\\nINSERT INTO `agences` VALUES (3,\\'Pacher\\',\\'5 avenue du lac\\',\\'56000\\',\\'Vannes\\',\\'France\\');\\nINSERT INTO `agences` VALUES (4,\\'Pourcoipahici\\',\\'45 boulevard Leon Blum\\',\\'56100\\',\\'Lorient\\',\\'France\\');\\nINSERT INTO `agences` VALUES (5,\\'Quiquanveu\\',\\'45 rue de Siam\\',\\'29000\\',\\'Brest\\',\\'France\\');\\nINSERT INTO `agences` VALUES (6,\\'Pafameu\\',\\'35 route de Lorient\\',\\'35000\\',\\'Rennes\\',\\'France\\');\\nINSERT INTO `agences` VALUES (7,\\'Padarnac\\',\\'45 rue du Soleil\\',\\'31000\\',\\'Toulouse\\',\\'France\\');\\nINSERT INTO `agences` VALUES (8,\\'Ass&eacutebienpourtoi\\',\\'5 place de la Lune\\',\\'33000\\',\\'Bordeaux\\',\\'France\\');\\nINSERT INTO `agences` VALUES (9,\\'Fal&eacutepa\\',\\'18 boulevard des bavards\\',\\'29990\\',\\'&Icircle de Sein\\',\\'France\\');\\nINSERT INTO `agences` VALUES (10,\\'Pacherdutou\\',\\'15 boulevard des muets\\',\\'75001\\',\\'Paris\\',\\'France\\');\\nINSERT INTO `agences` VALUES (11,\\'Pourcoipala\\',\\'18 boulevard de la mer\\',\\'22300\\',\\'Lannion\\',\\'France\\');\\nINSERT INTO `agences` VALUES (12,\\'Viendonc\\',\\'18 route de la plage\\',\\'78000\\',\\'Versailles\\',\\'France\\');\\nCOMMIT;\\n', '', ); }).catch(() => {}); \ud83d\udcc4 Accueil","title":"Bases de Donn\u00e9es"},{"location":"TNSI/Revisions/Revisions/","text":"\ud83d\udc0d Exercices - PYTHON Exercice 1 : Somme d'\u00e9l\u00e9ments dans un tableau Ecrire une fonction somme qui prend en param\u00e8tre une listte d'entier et qui renvoit la somme des \u00e9l\u00e9ments du tableau R\u00e9sultat \u00e0 obtenir Python 1 2 print ( somme ([ 1 , 2 , 3 ])) 6 ### Lancer tab = [1,2,3,4,5,6,7,8,9,10]bksl-nlbksl-nlassert(somme(tab)) == 55bksl-nlbksl-nl Valider 10/10 T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder tab = [1,2,3,4,5,6,7,8,9,10]bksl-nlbksl-nldef somme(tab : list) -> int :bksl-nl returnbksl-nl tab = [1,2,3,4,5,6,7,8,9,10]bksl-nlbksl-nldef somme(tab : list) -> int :bksl-nl total = 0bksl-nl for valeur in tab:bksl-nl total+=valeurbksl-nl return totalbksl-nl Exercice 2 : Recherche d'un maximum dans une liste Ecrire une fonction maximum qui prend en param\u00e8tre une liste d'entier et qui renvoit la valeur maximum du tableau R\u00e9sultat \u00e0 obtenir Python 1 2 3 4 maximum ([ 1 , 20 , 40 , 2 , 25 , 3 ]) 40 maximum ([ 120 , 20 , 40 , 2 , 25 , 3 ]) 120 ### Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder L = [1,20,40,2,25,3]bksl-nlbksl-nldef maximum(tab) :bksl-nlbksl-nl return bksl-nl Solution A venir Exercice 3 : Miroir miroir Ecrire une fonction miroir qui prend en param\u00e8tre une chaine de caract\u00e8re et qui renvoit cette cha\u00eene invers\u00e9e R\u00e9sultat \u00e0 obtenir Python 1 2 miroir ( 'Bonjour' ) ruojnoB ### Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder message = 'Bonjour'bksl-nlbksl-nldef miroir(ch) :bksl-nlbksl-nl return bksl-nl Solution A venir Exercice 4 : Moi en premier! Ecrire une fonction indice qui prend en param\u00e8tre une chaine de caract\u00e8re et un caract\u00e8re recherch\u00e9 et qui renvoit l'indice de la premi\u00e8re occurrence du caract\u00e8re recherch\u00e9 R\u00e9sultat \u00e0 obtenir Python 1 2 3 4 indice ( 'Bonjour' , 'o' ) 1 indice ( 'Bonjour' , 'r' ) 6 ### Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder message = 'Bonjour'bksl-nlbksl-nldef indice(ch, caractere) :bksl-nlbksl-nl return bksl-nl Solution A venir Exercice 5 : Je sais compter Ecrire une fonction nombres_occurrences qui prend en param\u00e8tre une chaine de caract\u00e8re et un caract\u00e8re et qui renvoit le nombre de fois qu'appara\u00eet le caract\u00e8re dans la cha\u00eene de caract\u00e8re R\u00e9sultat \u00e0 obtenir Python 1 2 3 4 5 6 nombres_occurrences ( 'Mississippi' , 'o' ) 0 nombres_occurrences ( 'Mississippi' , 'i' ) 4 nombres_occurrences ( 'Mississippi' , 'M' ) 1 ### Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder ch = 'Mississippi'bksl-nlbksl-nldef nombrespy-undoccurrences(ch, caractere) :bksl-nlbksl-nl return bksl-nl Solution A venir \ud83d\udcc4 Accueil","title":"R\u00e9visions"},{"location":"TNSI/Revisions/Revisions/#exercices-python","text":"Exercice 1 : Somme d'\u00e9l\u00e9ments dans un tableau Ecrire une fonction somme qui prend en param\u00e8tre une listte d'entier et qui renvoit la somme des \u00e9l\u00e9ments du tableau R\u00e9sultat \u00e0 obtenir Python 1 2 print ( somme ([ 1 , 2 , 3 ])) 6 ### Lancer tab = [1,2,3,4,5,6,7,8,9,10]bksl-nlbksl-nlassert(somme(tab)) == 55bksl-nlbksl-nl Valider 10/10 T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder tab = [1,2,3,4,5,6,7,8,9,10]bksl-nlbksl-nldef somme(tab : list) -> int :bksl-nl returnbksl-nl tab = [1,2,3,4,5,6,7,8,9,10]bksl-nlbksl-nldef somme(tab : list) -> int :bksl-nl total = 0bksl-nl for valeur in tab:bksl-nl total+=valeurbksl-nl return totalbksl-nl Exercice 2 : Recherche d'un maximum dans une liste Ecrire une fonction maximum qui prend en param\u00e8tre une liste d'entier et qui renvoit la valeur maximum du tableau R\u00e9sultat \u00e0 obtenir Python 1 2 3 4 maximum ([ 1 , 20 , 40 , 2 , 25 , 3 ]) 40 maximum ([ 120 , 20 , 40 , 2 , 25 , 3 ]) 120 ### Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder L = [1,20,40,2,25,3]bksl-nlbksl-nldef maximum(tab) :bksl-nlbksl-nl return bksl-nl Solution A venir Exercice 3 : Miroir miroir Ecrire une fonction miroir qui prend en param\u00e8tre une chaine de caract\u00e8re et qui renvoit cette cha\u00eene invers\u00e9e R\u00e9sultat \u00e0 obtenir Python 1 2 miroir ( 'Bonjour' ) ruojnoB ### Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder message = 'Bonjour'bksl-nlbksl-nldef miroir(ch) :bksl-nlbksl-nl return bksl-nl Solution A venir Exercice 4 : Moi en premier! Ecrire une fonction indice qui prend en param\u00e8tre une chaine de caract\u00e8re et un caract\u00e8re recherch\u00e9 et qui renvoit l'indice de la premi\u00e8re occurrence du caract\u00e8re recherch\u00e9 R\u00e9sultat \u00e0 obtenir Python 1 2 3 4 indice ( 'Bonjour' , 'o' ) 1 indice ( 'Bonjour' , 'r' ) 6 ### Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder message = 'Bonjour'bksl-nlbksl-nldef indice(ch, caractere) :bksl-nlbksl-nl return bksl-nl Solution A venir Exercice 5 : Je sais compter Ecrire une fonction nombres_occurrences qui prend en param\u00e8tre une chaine de caract\u00e8re et un caract\u00e8re et qui renvoit le nombre de fois qu'appara\u00eet le caract\u00e8re dans la cha\u00eene de caract\u00e8re R\u00e9sultat \u00e0 obtenir Python 1 2 3 4 5 6 nombres_occurrences ( 'Mississippi' , 'o' ) 0 nombres_occurrences ( 'Mississippi' , 'i' ) 4 nombres_occurrences ( 'Mississippi' , 'M' ) 1 ### Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder ch = 'Mississippi'bksl-nlbksl-nldef nombrespy-undoccurrences(ch, caractere) :bksl-nlbksl-nl return bksl-nl Solution A venir \ud83d\udcc4 Accueil","title":"\ud83d\udc0d Exercices - PYTHON"},{"location":"xtra/end_REM/","text":"","title":"end REM"},{"location":"xtra/start_REM/","text":"","title":"start REM"}]}